/* deno-fmt-ignore */ import {fooga, getBindingValueString, templater2, smartDedent5, pop3, moduleExports, joinPath, expandPath, isDecimal, hasPercentage, parsePercentage, Matrix, isInteger, isEquation, isObjectObject, getExtraIndent, shellUnescape, assertEqual, asyncToggle, touched, chosen, lastOf, firstOf, isBlockEnter, group3, loremIpsum, exportString, deepToggle, maybeNewlineIndent, onAndOff, flattenModule, isModule, isNativeHtmlTag, partitionByValues, strcall, getLongest2, must, mconfig, unreachable, storager, joiner, removeVeryStartingComments, ireplace, removeCommentsInPlace, editf, getLineTokens, IndexedStore, abstractError, bool, xassert, getSetLines, inMiddle, replaceLast, ensureExtension, multipleReplacer, getGradeLevel, constructEdit, getYear, Modulus, wrapClassMethods, proseReplacer, parseComments, parseFunctionDictComments, todo, dictAssertion, boundModularIncrement, construct, reduceToString2, pageTurner, assignCumulative, defaultMergeStrategy, dictSetter3, toArguments, reTemplate, parseFrontmatter, typeAssertion, defineGetter, assignAllowed, simpleRecursiveWalk, simpleArgument, exprTemplater, stringifyIfNotPrimitive, panic, stringerf, wrapFunction, regexTemplater, iso8601, strftime, walkChildEntries, getFiletype, matchf, isUrl, looksLikeFunction, toArgument2, notNull, CumulativeStorage2, simpleAssign, findAndMatch, infuseObjectArray, regexGetter, splitArg, isJavascriptComment, runTest, everyOther, splitByRange, get_regex, getImports, isJavascriptFile, isValidDateString, WriteObject, equalityf, group2, splitOnce2, dedent4, isLowerCase, looksLikeRegExpString, isRegExpString, getDependencies, camelSplit, toggle3, countf, isLiteralObject, bindMethodsAndState2, call, mget3, looks_like_object_function, create_functions_from_master, toStringArgumentPretty, codeChunks, smart_map, run_tests, hasStartingCallable, mapTemplate, aliaser, fixSelector, htmlTags, removePythonComments, simpleStringBreaker, colonConfig, operations, error, redColon, so2, group, parseSingleLineJson, Items, findDependencies, tryf, find4, localeString, cssComment, colonConfigf, trimArray, parseCallable, bringToLifeTextFix, localBringToLife, getCaller4, getErrorStack, forEach, getBindings, getExports, matchstr, filter4, allEqual, count, isNativeFunction, repeat, eat, getIndentAndText, StopWatch, stringDictSetter, getFunctionInfo, runRef, toLines, hasCallable, getProseWords, tally, paramify, codeSplit, debugConfig, logConfig, blueColon, toStringArgument3, stringCallable, simpleBinding, dashSplit4, appendBelow, appendAbove, removeLineComments, prependIfNecessary, smartDedent4, blueSandwich, walk4, findLineIndex, parseAB, applyTransform, kebabCase, getExcerpt, sortObject, buildFunction, maybeSort, parseFunction, isTypable, frontMatter, dictEntry, insertAfterIndex, State, bindMethods, cpop, tagRE, toggle2, createFunction2, assignIncrementedIndex, ufa, assignArray, regexFromComment, createParsersFromObject, imatch, globalConsoleDebug, bindMethodsAndState, isQuestion, oxfordComma, isUpperCase, getFunctionIdentifier, filter3, match, getMatch, alternatef, reCombine, assertion2, deepEqual, hasDollar, so, deepAssign, Tally, getFunctionNames, throwError, notEqual, tryString, prettyPrintCodeSnippet, prettyPrintErrorStack, iter, quotify, transformerf, assign, defineBinding, jspy, linebreak, stringCall2, reduce3, getClassParameters, assignOnTop2, isIdentifier, ndy, dashSplit3, runFunctionFromRef, equalf, alphabet, stateGetterFromSchema, mreplace, require, topLineComment, isChinese, replacef, ignoref, codeLibrary, splitLines, addArgumentQuotes, getBindings2, addCaret, mget2, getStartingConfig, incrementalEat, strlen, hr, setOnce, unescapeHtml, oxford, breakerf, runTests, map3, dateSplit, transformDict, walk3, toRegExp, tryAgainf, assertNotNull, getArgumentObject, isArgumentObject, typef, requireArg, keyAndValue, assignf, stateGetter3, objectFromArguments2, assignDefaults, transformValue, assign3, assignFresh3, evaluate3, scopedEvaluator, objectFromArguments, enforce, sub, filterObject, extractStartingJsonLikeConfig, unbrackify, newlineIndent2, deleteLine, both, normalizeIndent, getComment, secondComment, isStringRegExp, dashSplit2, clock, warning, errorStringify, alert, labelCase, bottomComment, stringCompose, getAnyIdentifier, chalkf, getNumbers, partitions, has, addUnit, toCallable, unquote, filter2, warn2, join2, caller2, assignOnce, longShort, shortLong, argPop, caller, assignOnTop, toggle, defineWindow, unescapeNewlines, escapeQuotes, unescapeQuotes, escapeNewlines, setAliases, announceCaller, removeStartingComments, smartBind, assignExisting, isObjectWithKey, eatStart, modularIncrementItem, getRegex, runFunction, isObjectLikeArray, itemGetter2, getAllKeys, prefixSlice, hasQuotes, assertion, diff, toggleState, initState, dunder, objectGetter, superTransform, popFilter, testRunner, assert2, insertAtDollar, popEmptyLine, getOptions, mergeSpecs, sortByKeys, map2, strictMessengerAssert, smartSplit, chalk4, typeLog, getFunctionName, Clock, search3, MyError, fuzzyMatch3, debugDisplay, getCaller3, messengerAssert, camelSlice, setPrototype, assignAliases, display, modifyNumber, toDict, setPush, modularIncrementIndex, longstamp, popIndex, toggleOnOff, locWrap, walk2, typeMatch, prettyStringify, getIdentifiers, CustomError, argMatch, brackify2, smartestDedent, modularIncrementNumber, AbstractMethodError, allUnique, Trie, boundarySplit, numberBoundarySplit, nodeLog, getFirst, defineProperty, supermix, partial, timeLog, timestamp, raise, getIdentifier, conditionalPrefix, conditionalSuffix, QueryList, fuzzyMatch2, buildDict, getTextAndCommand, sprawlFactory, getParameters2, pushf, intersection, union, blue, green, sandwich, getLastSpaces, smartDedent3, red, sort, debounce, checkValue, getCodeChunks, logf, boundary, myError, conditional, isStringFunction, toSpaces, objectf, searchAll, difference, singleQuote, itemGetter, slice2, mergeObjects, once, dashSplit, nchalk, coerceToObject, ArrayState, exporter2, indent2, iterator, removeAllComments, countParams, cumulativeSchemaAssign, argKwargSplit, argParse, removeInlineComments, getFrontMatter, hasHtmlSuffix, lazyArray, isThisFunction, escapeHTML, getKwargs2, search2, toStringArgument, createFuzzyMatch, edit2, splice, zip, merge2, argArgsKwargs, fill2, chalk, vueWrap, splitArray, splitArray2, warn, makeRunner2, searchf2, smartDedent2, dedent2, toArray2, stateGetter2, sortByIndex, IndexedCache, argo, curry2, doUntil2, evaluate2, findall2, findIndex2, findItem2, getCaller2, getErrorStack2, isJson, indexGetter2, insert2, pop2, parseError2, remove2, reduce2, testf2, type2, unshift2, waterfall2, xsplit2, Cache, cumulativeAssign, replaceBefore, topComment, isAsyncFunction, mapSort, getFileURI, getQuotes, isClassObject, isInitialized, getFallback, bindingRE, addObjectOrObjectProperty, forDoubles, isCss, log, iterate, backAndForth, round, iteratorWrapper, toJSON, isFromMap, toString, empty, conditionalString, getConfigArg, hasKey, errorWrap, successWrap, check, toPoints, bind, mixinAliases, isPercentage, isBasicType, reducerStrategy, gather, entries, stateGetter, methodCase, vueCase, push2, smarterIndent, lineSplit, Store, isSingleLetter, prepareText, isSymbol, getShortest, slice, KeyError, deepCopy, argsKwargs, isError, isColor, list, objectEditor, matchall, makeFastRunner, announce, hasLetter, filter, reduce, stringCall, capitalizeName, stop, proseCase, lineDitto, mixinSetters, modularIncrement, distinct, definedSort, groupBy, reWrap2, fuzzyMatch, isPlural, Element, parseError, isPrimitiveArray, callableArgsKwargs, waterfall, defineVariable, info, flat2D, splitThePage, handleError, dedent, TypeAssertion, createFunction, pluralize, remove, Group, PageStorage, Storage, UniqueStorage, Watcher, arrayToDict, addProperty, addQuotes, argWrapFactory, assert, abrev, abf, addExtension, assignFresh, antif, atFirst, atSecond, backspace, bindObject, breaker, blockQuote, brackify, bringToLife, comment, countCaptureGroups, capitalizeTitle, classMixin, callableRE, camelToTitle, curry, createVariable, changeExtension, curryStart, curryEnd, capitalize, copy, camelCase, compose, char2n, camelToDash, deepMerge, datestamp, doublef, dictSetter, dictSetter2, dsearch, doUntil, dashCase, doubleQuote, dict, dictGetter, depluralize, dreplace, dictf, endsWithWord, exporter, edit, exists, evaluate, extend, find, flatMap, fill, fixUrl, functionGetter, findall, fixPath, flat, fparse, findIndex, firstLine, ftest, getKwargs, getFirstName, getBindingName, getParameters, getLastWord, getCodeWords, getCodeWords2, getIndent, getExtension, getLast, getLongest, getChunks, getCaller, getStackTrace, getConstructorName, getFirstWord, getWords, getSpaces, hasComma, hasSpaces, hasHtml, hasBracket, hasNewline, hasCaptureGroup, hasEquals, hasValue, hasCamelCase, hasNumber, hackReplace, insert, indexGetter, incrementf, isCallable, isQuote, isEven, isOdd, isLast, isHTML, isNode, interweave, inferLang, isString, isArray, isObject, isDefined, isFunction, isPrimitive, isNumber, isSet, isNestedArray, indent, isNull, isWord, isBoolean, isRegExp, identity, isObjectLiteral, isJsonParsable, isCapitalized, isNewLine, isObjectArray, isStringArray, isClassFunction, joinSpaces, join, keyArrayToObject, lowerCase, linebreakRE, len, lineGetter, lineCount, lastLine, logConsole, makeRunner, mixin, modularf, matchGetter, merge, mget, map, mergeOnTop, mergeToObject, mapFilter, noop, nestPush, no, newlineIndent, n2char, objectWalk, overlap, objectToString, opposite, pipe, parseTopAttrs, pascalCase, partition, parens, push, pop, parseJSON, rigidSort, removeQuotes, rep, removeComments, range, removeExtension, rescape, reverse, reWrap, reduceToString, repeatUntil, swapKey, sayhi, swap, splitMapJoin, splitCamel, smallify, search, stringify, shared, smartDedent, stringBreaker, sleep, split, snakeCase, stringArgument, sorted, splitOnce, searchf, secondLine, titleCase, textOrJson, toNumber, toArgument, toNestedArray, test, type, tail, transformObject, trim, testf, toArray, templater, totalOverlap, upperCase, unique, uncapitalize, unzip, wrap, walk, wrapf, xsplit, yes, zip2} from "/home/kdog3682/2023/utils.js"
/* deno-fmt-ignore */ import * as variables from "/home/kdog3682/2023/variables.js"
/* deno-fmt-ignore */ import {append, requestAppend, requestWrite, denoImports, notify, read, denoFileRunner, cwd, readdir, rpw, bash, sysArgs, write, npath} from "/home/kdog3682/2024-javascript/nodekit/deno.js"

export { finish }

function finishConfig(value, config) {
    if (empty(value)) {
        return
    }
    if (isError(value)) {
        console.log("ERROR", value)
        return
    }

    if (config.after2) {
        value = doConfigAfter2(value, config)
    } else if (config.after) {
        return configAfter2Ref[config.after](value, config)
        return doConfigAfter(value, config)
    }
    if (config.export1000) {
        write("")
        return
    }
    if (config.saveToCopyBuffer) {
        return write(
            "/home/kdog3682/2024/vim-copybuffer.txt",
            value,
        )
    }

    if (config.exportFile && config.outputCode) {
        return write(config.exportFile, config.outputCode)
    }
    if (config.exports) {
        const f = (key) => {
            const value = config[key]
            if (isString(value)) {
                return value
            }
            return defineBinding(key, value)
        }
        const s = "\n\n" + join(config.exports.map(f))
        append("examples.js", s)
        return
    }

    if (config.exportAsLezerModule) {
        return exportAsLezerModule(value, config)
    }
    if (config.exportAs) {
        /** bookmarkId: 1705045625 **/
        //todo: /home/kdog3682/2023/lezer.template.js
        //export as jsdoc
        return exportWithJSDoc(config.exportAs, payload)
        console.log(config)
        return "aaaa"
        if (isObject(config.export)) {
            throw "not done yet"
            return exportConfigObject(config.export, config)
        }
        return writeExportFile(config.export, config.code)
    }
    if (config.outpaths) {
        return forEach(pair(config.outpaths, values), write)
    }
    if (config.variableName) {
        value = createVariable(config.variableName, value)
    }

    if (config.debug) {
        return blue("Result", value)
    }
    if (config.exportAsHTML) {
        return write("clip.html", value, true)
    }
    // moved to "after"
    // if (config.vim) {
    // const outpath = config.outpath || '/home/kdog3682/.vimrc'
    // return append(outpath, toVimVariable(config.vim, value))
    // }

    if (config.write) {
        return write(config.write, value)
    }
    if (config.append) {
        return append(config.append, value)
    }
    if (config.outpath) {
        return write(config.outpath, value)
    }
    if (config.pretty) {
        return console.loggg(value)
    }
    if (config.export) {
        return exportCodeAsFile(config.export, config.code)
    }
    if (config.exportArg) {
        return write(config.exportArg, getArg(config))
    }
    blueSandwich("result", value)
}
function doConfigAfter(value, config) {
    if (empty(value)) {
        red("empty value @ doConfigAfter")
        return
    }

    const key = config.after
    const payload = isObject(config.after)
        ? configObjectHandler(value, config.after, config)
        : doConfigAfterRef[config.after](value, config)
    const args = payload ? [key, payload] : ["result", value]
    blueSandwich(...args)
}
function doConfigAfter2(value, config) {
    return configAfter2Ref[config.after2](value, config)
}

const configAfter2Ref = {
    /* insertion-point-below-object */
    // append_result_to_self_and_create_section,
    createArgFile(value, config) {
        const onEnd = (node) => {}
        function onBranchExit(node) {
            const { text, depth } = node
        }
        function onLeafEnter(node) {
            const { text, depth } = node
        }

        const b = new JavascriptBuilder()
        b.import("utils.js")
        b.import("StateContext.js")
        b.define("arg", value)
        b.define("config", { onLeafEnter, onBranchExit, onEnd })
        b.define("parser", "StateContext.createParser(config)")
        b.text("parser(arg)")
        return b.toString()
    },
    appendSelf(value, config) {
        append(config.vim.file, value)
    },
    vim(value, config) {
        assert(config.name)
        if (empty(value)) {
            return
        }
        delete config.write
        const file = config.outpath || config.append ||
            "/home/kdog3682/.vimrc"
        const payload = toVimVariable2(config.name, value)
        append(file, payload)
        return
    },
    save_codespace_file(value, config) {
        const name = match(
            p.parse(config.vim.file).name,
            /\w[\w-]+/,
        )
        const path = name + ".workspace.json"
        const outpath = incrementFile(path)
        write(outpath, value)
        return outpath
    },
}
const finishRef = {
    foo: 1,
}
function finish(value, config) {
    if (isError(value)) {
        console.log("ERROR", value)
        return
    }
    if (empty(value)) {
        return
    }

    const type = config.after
    const fn = finishRef[type]
    if (fn) {
        value = fn(value, config)
    } else {
        const keys = Object.keys(config)
        const possible = keys.filter((key) =>
            finishRef2.hasOwnProperty(key)
        )
        const key = possible[0]
        switch (possible.length) {
            case 0:
                break
            case 1: {
                const fn = finishRef2[key]
                value = fn(config[key], value, config)
            }
            default:
                break
        }
    }

    if (empty(value)) {
        return
    }
    if (config.write) {
        return write(config.write, value)
    }
    if (config.append) {
        return append(config.append, value)
    }
    if (config.outpath) {
        return write(config.outpath, value)
    }
    blueSandwich("result", value)
}

function simpleImplied(s, ...files) {
    const javascriptIgnore = variables.builtInFunctions.concat(
        variables.builtInClasses,
    ).concat(variables.javascriptReservedWords).concat([
        "console",
        "Math",
        "localStorage",
        "RegExp",
    ])

    function mask(s) {
        return s.replace(/(?<!\\)'.*?(?<!\\)'/g, "")
            .replace(/(?<!\\)".*?(?<!\\)"/g, "")
            .replace(/(?:\.\w+)+/g, "")
    }
    const regex = /[a-zA-Z]\w{2,}/g
    const implied = unique(
        findall(regex, mask(s)),
        javascriptIgnore,
    )
    return implied
}

function buildImports(implied, files) {
    const fn = (file) => [file, getExports(read(file))]
    const exports = files.map(fn)
    const storage = new Storage()
    const missing = []
    for (const arg of implied) {
        for (const [file, group] of exports) {
            if (group.includes(arg)) {
                storage.add(file, arg)
                break
            }
        }
        missing.push(arg)
    }
    if (missing) {
        console.log({ missing })
    }
    return join(
        storage.entries.map(([k, v]) => denoImports(k, v)),
    )
}
function generateAppFile(s, name) {
    const code = s.replace(/\bmain\b/g, name)
    const implied = simpleImplied(code)
    const files = [
        "/home/kdog3682/2024-javascript/nodekit/deno.js",
        "/home/kdog3682/2023/utils.js",
    ]
    const imports = buildImports(implied, files)

    const template = `
        $imports
        
        $code

        export default $name
        
    `
    const text = templater(template, { imports, code, name })
    return text
}

const finishRef2 = {
    vimCommand(desc, result, config) {
        const name = camelCase(desc)
        const type = config.inpath ? "rpw" : "xxx"
        const file = addExtension(name, "js")
        const entry = {
            timestamp: Date.now(),
            desc,
            name,
            file,
            type,
        }
        const ext = ".js"
        const dir =
            "/home/kdog3682/2024-javascript/generated/apps/"
        const fileText = generateAppFile(config.raw, name)
        const outpath = npath(dir, name, "js")
        requestWrite(outpath, fileText)
        const jsonpath = npath(dir, "index", "json")
        requestAppend(jsonpath, [entry])
    },
    expect(expect, value) {
        testEqual(value, expect)
    },
}

function testEqual(a, b) {
    const success = deepEqual(a, b)
    if (success) {
        console.log("the values match!", { value: a })
    } else {
        console.log("the two values do not match")
        console.log("-------------")
        console.log(a)
        console.log("-------------")
        console.log(b)
        console.log("-------------")
    }
}
